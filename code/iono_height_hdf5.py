#!/usr/bin/python3
# coding: utf-8
import h5py
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import tqdm
from distanceAlongWavevector import wavevector_baseline
from known_transmitters import get_transmitter_coords
from lsl.common import stations

'''
This script takes an HDF5 file generated by relativePhase.py,
averages it, and computes ionospheric height.
'''
##################################################
## Parameters:
station = stations.lwasv

transmitter = 'SFe'
#transmitter = 'WWV'

if transmitter == 'SFe':
    # twenty seconds
    #hdf5_file = 'phase_058846_00123426_s0020_r224.hdf5'
    # big boy
    hdf5_file = '../../data/phase_058846_000123426_r224.hdf5'
    reference_stand = 224
    center_freq = 5351500.0

if transmitter == "WWV":
    hdf5_file = './phase_058628_001748318_r173.hdf5'
    reference_stand = 173
    center_freq = 10e6

fs = 100000
average = True
target_fs = 2.5
rolling_avg_length = 200
##################################################

transmitter_coords = get_transmitter_coords(transmitter)

f = h5py.File(hdf5_file, 'r')

center_wl = 3e8/center_freq

taps = [1] * rolling_avg_length

av_len = int(fs/target_fs) # resample

plt.close('all')
fig, ax = plt.subplots(3, 1, figsize=(10,10))
#fig2, ax2 = plt.subplots(1,1)

_, _, tx_rx_distance = station.get_pointing_and_distance((transmitter_coords[0], transmitter_coords[1], 0))

for k in f['relative'].keys():
    print("\n" + k)
    full = f['relative'][k]
    b = wavevector_baseline(reference_stand, int(k), station, transmitter_coords) / center_wl
    phase_lim = 2 * np.pi * b

    if average:
        averaged = np.zeros(len(full) // av_len + 1)
        for idx in tqdm.trange(len(full) // av_len):
            averaged[idx] = np.mean(full[idx * av_len : (idx + 1) * av_len])

        last_idx = len(averaged) - 1
        averaged[last_idx] = np.mean(full[last_idx * av_len:])

        first_sample = averaged[0]
        state = signal.lfilter_zi([1]*rolling_avg_length, rolling_avg_length)
        toplot, state = signal.lfilter([1] * rolling_avg_length, rolling_avg_length, averaged, zi=state)

        t = np.arange(len(averaged)) * 1.0/target_fs
        # t = t/60.0 #convert to minutes

    else:
        toplot = np.array(full)
        t = np.arange(len(toplot)) * 1.0/fs * 1.0/60

    l = ax[0].plot(t, toplot, label=u"{} ({:.3f}λ)".format(k, b))
    ax[0].plot((0,t[-1]), (phase_lim, phase_lim), '--', color=l[0].get_color())
    ax[0].plot((0,t[-1]), (-phase_lim, -phase_lim), '--', color=l[0].get_color())

    aoa = np.arccos(toplot / (2*np.pi*b))

    ax[1].plot(t, aoa * 360 / (2*np.pi), label=u"{} ({:.3f}λ)".format(k, b))

    height = tx_rx_distance/2 * np.tan(aoa)

    ax[2].plot(t, np.abs(height/1e3), label=u"{} ({:.3f}λ)".format(k, b))



#ax[0].set_xlabel("Time (min)")
ax[0].set_xlabel("Time (s)")
ax[0].set_ylabel("Relative Phase (radians)")
ax[0].legend()

#ax[1].set_xlabel("Time (min)")
ax[0].set_xlabel("Time (s)")
ax[0].set_ylabel("Relative Phase (radians)")
ax[1].set_ylabel("Angle of arrival from horizontal (degrees)")
ax[1].legend()

ax[2].set_ylim([0, 2000])
#ax[2].set_xlabel("Time (min)")
ax[0].set_xlabel("Time (s)")
ax[0].set_ylabel("Relative Phase (radians)")
ax[2].set_ylabel("Reflecton height (km)")
ax[2].legend()

plt.show()
